* クエリーの書式

sennaで作成したインデックスに対して以下に示す書式によって検索を行うことができます。
MySQLのBOOLEAN MODEと類似した形式になっていますが、その他のバインディングでも
同じ書式のクエリーを使用することができます。

* プラグマ

クエリ文字列の先頭に、クエリの処理方法を指定するプラグマを埋め込むことができます。

- プラグマは必ずクエリ文字列の冒頭に存在しなければなりません。(先頭に空白を入れてはいけません)
- 複数のプラグマを指定する場合は、間に空白を入れてはいけません。

** *E数値1[,数値2]

検索結果の数が数値1よりも小さい場合、完全一致→非わかち書き→部分一致の順に自動的に検索処理方法を切り替えます。
完全一致でヒットした文書と比べて非わかち書き一致、部分一致でヒットした文書には数値2分だけ小さいスコアを付与します。数値2を省略した場合は既定値(=2)と解釈されます。数値1に負の数を指定した場合は以下のように処理します。

 -1: 完全一致検索のみを行う
 -2: 非わかち書き検索のみを行う
 -3: 完全一致検索と非わかち書き検索のみを行う
 -4: 部分一致検索のみを行う
 -5: 完全一致検索と部分一致検索のみを行う
 -6: 非わかち書き検索と部分一致検索のみを行う
 -7: 完全一致検索,非わかち書き検索,部分一致検索の全てを行う

例:

 *E10,3

検索結果数が10件以下だった場合に検索処理方法を順次切り替え、スコアを3ずつ小さくします。

** *D演算子

演算子の既定値(演算子を省略した場合にどの演算を行うか)を指定します。

指定できる演算子は、OR, +, - のいずれかです。ORを指定すれば以降のクエリはMySQLのBOOLEAN MODE互換になり、+を指定すれば、多くのwebサーチエンジンっぽくなります。

例1:

 *D+ abc def

abcとdefを両方含む文書を検索します。

例2:

 *DOR abc def

abcとdefのいずれかを含む文書を検索します。

* 演算子

** +単語
ある単語が存在しなければならないという条件を表す。

(いわゆるAND)

** -単語
ある単語が存在してはならないという条件を表す。

(いわゆるNOT)

** OR 単語
ある単語は存在しなくてもよいが、存在する場合には文書の検索スコアをあげる、という条件を表す。

(いわゆるOR)

ORは大文字で記載しなければならない。


** ~単語 
ある単語は存在してもよいが、存在する場合には文書の検索スコアを下げる、という条件を表す。

** <単語 または >単語
それぞれの単語の重みを下げる(<)、または、あげる(>)。

** (単語・演算子群) 
単語・演算子群をグループ化します。

例えば、-(+全文 +検索)のように用います。

** 単語*
ある単語から始まる文字列を検索する、という条件を表す。

** "単語" 
単語と完全に合致する単語を含む、という条件を表す。

** *S[数値]"文字列"
文字列と関連する文書を検索します。文字列から抽出する特徴語の数を数値に指定します。

** *N[数値]"文字列"
文字列に含まれる複数の語が、近傍に含まれる文書を検索します。近傍の範囲の上限となる語数を数値に指定します。N-gramの場合は、文字数を指定します。

** *W[数値[:重み][,数値[:重み]]...
数値で指定されたセクション番号のみを対象に検索します。セクションごとに検索スコアの倍数を指定することができます。重みは、省略された場合1となります。負の重みも指定することができます。
